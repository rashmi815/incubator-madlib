# coding=utf-8
#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

# Single Source Shortest Path

# Please refer to the sssp.sql_in file for the documentation

"""
@file sssp.py_in

@namespace graph
"""

import plpy
from graph_utils import *
from utilities.control import MinWarning
from utilities.utilities import _assert
from utilities.utilities import extract_keyvalue_params
from utilities.utilities import unique_string
from utilities.utilities import _string_to_array
from utilities.utilities import split_quoted_delimited_str
from utilities.validate_args import table_exists
from utilities.validate_args import columns_exist_in_table
from utilities.validate_args import table_is_empty
from utilities.validate_args import get_cols_and_types
from utilities.validate_args import get_expr_type

m4_changequote(`<!', `!>')

def _validate_bfs(vertex_table, vertex_id, edge_table, edge_params,
    source_vertex, out_table, max_distance, directed, grouping_cols_list, **kwargs):

    validate_graph_coding(vertex_table, vertex_id, edge_table, edge_params,
        out_table,'BFS')

    _assert((max_distance >= 0) and isinstance(max_distance,int),
        """Graph BFS: Invalid max_distance type or value ({0}), must be integer, be greater than or equal to 0 and be less than max allowable integer (2147483647).""".
        format(max_distance))
    _assert(isinstance(directed,bool),
        """Graph BFS: Invalid value for directed ({0}), must be boolean.""".
        format(directed))

    _assert(isinstance(source_vertex,int),
        """Graph BFS: Source vertex {source_vertex} has to be an integer.""".
        format(**locals()))
    src_exists = plpy.execute("""
        SELECT * FROM {vertex_table} WHERE {vertex_id}={source_vertex}
        """.format(**locals()))
    if src_exists.nrows() == 0:
        plpy.error(
            """Graph BFS: Source vertex {source_vertex} is not present in the vertex table {vertex_table}.""".
            format(**locals()))

    vt_error = plpy.execute(
        """ SELECT {vertex_id}
            FROM {vertex_table}
            WHERE {vertex_id} IS NOT NULL
            GROUP BY {vertex_id}
            HAVING count(*) > 1 """.format(**locals()))

    if vt_error.nrows() != 0:
        plpy.error(
            """Graph SSSP: Source vertex table {vertex_table} contains duplicate vertex id's.""".
            format(**locals()))

    _assert(not table_exists(out_table+"_summary"),
        "Graph SSSP: Output summary table already exists!")

    if grouping_cols_list is not None:
        _assert(columns_exist_in_table(edge_table, grouping_cols_list),
            """Graph SSSP: Not all columns from {grouping_cols_list} are present in edge table ({edge_table}).""".
            format(**locals()))

    return None

def graph_bfs(schema_madlib, vertex_table, vertex_id, edge_table,
        edge_args, source_vertex, out_table, max_distance, directed, grouping_cols, **kwargs):

    """
    Breadth First Search algorithm for graphs [1].
    Args:
        @param vertex_table    Name of the table that contains the vertex data.
        @param vertex_id       Name of the column containing the vertex ids.
        @param edge_table      Name of the table that contains the edge data.
        @param edge_args       A comma-delimited string containing multiple
                               named arguments of the form "name=value".
        @param source_vertex   The source vertex id for the algorithm to start.
        @param out_table       Name of the table to store the result of SSSP.
        @param max_distance    Maximum distance from the source_vertex to search for.
        @param directed        Graph will be treated as directed if this boolean flag 
                               is set to TRUE. Graph is treated as undirected by default.
        @param grouping_cols   The list of grouping columns.

    [1] https://en.wikipedia.org/wiki/Breadth-first_search
    """

    with MinWarning("warning"):

        INT_MAX = 2147483647
        INFINITY = "'Infinity'"
        EPSILON = 0.000001

        message = unique_string(desp='message')

        # oldupdate = unique_string(desp='oldupdate')
        # newupdate = unique_string(desp='newupdate')

        params_types = {'src': str, 'dest': str, 'weight': str}
        default_args = {'src': 'src', 'dest': 'dest', 'weight': 'weight'}
        edge_params = extract_keyvalue_params(edge_args,
                                            params_types,
                                            default_args)

        # Prepare the input for recording in the summary table
        if vertex_id is None:
            v_st= "NULL"
            vertex_id = "id"
        else:
            v_st = vertex_id
        if edge_args is None:
            e_st = "NULL"
        else:
            e_st = edge_args
        if max_distance is None:
            d_st= "NULL"
            max_distance = INT_MAX
        else:
            d_st = max_distance
        if directed is None:
            dir_st= "NULL"
            directed = False
        else:
            dir_st = directed
        if grouping_cols is None:
            g_st = "NULL"
            glist = None
        else:
            g_st = grouping_cols
            glist = split_quoted_delimited_str(grouping_cols)

        src = edge_params["src"]
        dest = edge_params["dest"]
        weight = edge_params["weight"]

        distribution = m4_ifdef(<!__POSTGRESQL__!>, <!''!>,
            <!"DISTRIBUTED BY ({0})".format(vertex_id)!>)
        local_distribution = m4_ifdef(<!__POSTGRESQL__!>, <!''!>,
            <!"DISTRIBUTED BY (id)"!>)

        # is_hawq = m4_ifdef(<!__HAWQ__!>, <!True!>, <!False!>)
        _validate_bfs(vertex_table, vertex_id, edge_table,
            edge_params, source_vertex, out_table, max_distance, directed, glist)

        # plpy.execute(" DROP TABLE IF EXISTS {0},{1},{2}".format(
        #     message,oldupdate,newupdate))

        # Initialize grouping related variables
        comma_grp = ""
        comma_grp_e = ""
        comma_grp_m = ""
        grp_comma = ""
        checkg_oo = ""
        checkg_eo = ""
        checkg_ex = ""
        checkg_om = ""
        group_by = ""

        if grouping_cols is not None:
            comma_grp = " , " + grouping_cols
            group_by = " , " + _grp_from_table(edge_table,glist)
            comma_grp_e = " , " + _grp_from_table(edge_table,glist)
            comma_grp_m = " , " + _grp_from_table("message",glist)
            grp_comma = grouping_cols + " , "

            # checkg_oo_sub = _check_groups(out_table,"oldupdate",glist)
            # checkg_oo = " AND " + checkg_oo_sub
            # checkg_eo = " AND " + _check_groups(edge_table,"oldupdate",glist)
            # checkg_ex = " AND " + _check_groups(edge_table,"x",glist)
            # checkg_om = " AND " + _check_groups("out_table","message",glist)

        # We keep a table of every vertex, the distance to that vertex from source
        # This table will be updated throughout the execution.
        dist_col = "dist"
        parent_col = "parent"
        curr_dist_val = 0
        plpy.execute(
            """ CREATE TABLE {out_table} AS ( SELECT
                    {grp_comma} 
                    {src} AS {vertex_id}, 
                    {curr_dist_val}::INT AS {dist_col},
                    {source_vertex}::INT AS {parent_col}
                    FROM {edge_table} LIMIT 0)
                {distribution} """.format(**locals()))

        # We keep a summary table to keep track of the parameters used for this
        # BFS run
        plpy.execute( """ CREATE TABLE {out_table}_summary  (
            vertex_table            TEXT,
            vertex_id               TEXT,
            edge_table              TEXT,
            edge_args               TEXT,
            source_vertex           INTEGER,
            out_table               TEXT,
            max_distance            INTEGER,
            directed                BOOLEAN,
            grouping_cols           TEXT)
            """.format(**locals()))
        plpy.execute( """ INSERT INTO {out_table}_summary VALUES
            ('{vertex_table}', '{v_st}', '{edge_table}', '{e_st}',
            {source_vertex}, '{out_table}', {d_st}, {dir_st}, '{g_st}')
            """.format(**locals()))

        # The initialization step is quite different when grouping is involved
        # since not every group (subgraph) will have the same set of vertices.

        # Example:
        # Assume there are two grouping columns g1 and g2
        # g1 values are 0 and 1. g2 values are 5 and 6
        
        plpy.execute("""
            INSERT INTO {out_table}
            SELECT {grp_comma} 
                {source_vertex} AS {vertex_id},
                {curr_dist_val} AS {dist_col},
                NULL AS {parent_col}
            """.format(**locals()))

        vct = 0
        if grouping_cols is not None:
            vct = 0
        else:
            if directed:
                vct = plpy.execute("""
                    SELECT COUNT(*) 
                    FROM {edge_table} 
                    WHERE (
                        {src} IN (
                            SELECT {vertex_id} FROM {out_table} 
                            WHERE {dist_col}={curr_dist_val}
                        ) 
                        AND 
                        {dest} NOT IN (SELECT {vertex_id} FROM {out_table})
                    )
                    """.format(**locals()))[0]['count']
            else:
                vct = plpy.execute("""
                    SELECT COUNT(*) 
                    FROM {edge_table} 
                    WHERE (
                        {src} IN ( 
                            SELECT {vertex_id} FROM {out_table} 
                            WHERE {dist_col}={curr_dist_val}
                        ) 
                        AND 
                        {dest} NOT IN (SELECT {vertex_id} FROM {out_table})
                    ) OR (
                        {dest} IN ( 
                            SELECT {vertex_id} FROM {out_table} 
                            WHERE {dist_col}={curr_dist_val}
                        ) 
                        AND 
                        {src} NOT IN (SELECT {vertex_id} FROM {out_table})
                    )""".format(**locals()))[0]['count']

            plpy.info("vct = {0}".format(vct))

        plpy.info("max_distance = {0}".format(max_distance))
        while vct > 0 and curr_dist_val < max_distance:
            plpy.info("curr_dist_val = {0}".format(curr_dist_val))

            if directed:
                plpy.execute("""
                    INSERT INTO {out_table}
                    SELECT {vertex_id}, {dist_col}, min({parent_col})
                    FROM (
                        SELECT {dest} AS {vertex_id}, 
                            {curr_dist_val}+1 AS {dist_col}, 
                            {src} AS {parent_col}
                        FROM {edge_table} 
                        WHERE (
                            {src} IN (
                                SELECT {vertex_id} FROM {out_table} 
                                WHERE {dist_col}={curr_dist_val}
                            ) 
                            AND 
                            {dest} NOT IN (SELECT {vertex_id} FROM {out_table})
                        )
                    ) t1
                    GROUP BY 1,2
                """.format(**locals()))

                curr_dist_val = curr_dist_val + 1

                vct = plpy.execute("""
                    SELECT COUNT(*) 
                    FROM {edge_table} 
                    WHERE (
                        {src} IN ( 
                            SELECT {vertex_id} FROM {out_table} 
                            WHERE {dist_col}={curr_dist_val}
                        ) 
                        AND 
                        {dest} NOT IN (SELECT {vertex_id} FROM {out_table})
                    )""".format(**locals()))[0]['count']

                plpy.info("curr_dist_val = {0}".format(curr_dist_val))
                plpy.info("vct = {0}".format(vct))

            else:
                plpy.execute("""
                    INSERT INTO {out_table}
                    SELECT {vertex_id}, {dist_col}, min({parent_col})
                    FROM (
                        SELECT {dest} AS {vertex_id}, 
                            {curr_dist_val}+1 AS {dist_col}, 
                            {src} AS {parent_col}
                        FROM {edge_table} 
                        WHERE (
                            {src} IN ( 
                                SELECT {vertex_id} FROM {out_table} 
                                WHERE {dist_col}={curr_dist_val}
                            ) 
                            AND 
                            {dest} NOT IN (SELECT {vertex_id} FROM {out_table})
                        )
                        UNION
                        SELECT {src} AS {vertex_id}, 
                            {curr_dist_val}+1 AS {dist_col}, 
                            {dest} AS {parent_col}
                        FROM {edge_table} 
                        WHERE (
                            {dest} IN (
                                SELECT {vertex_id} FROM {out_table} 
                                WHERE {dist_col}={curr_dist_val}
                            ) 
                            AND 
                            {src} NOT IN (SELECT {vertex_id} FROM {out_table})
                        )
                    ) t1
                    GROUP BY 1,2
                """.format(**locals()))

                curr_dist_val = curr_dist_val + 1
                
                vct = plpy.execute("""
                    SELECT COUNT(*) 
                    FROM {edge_table} 
                    WHERE (
                        {src} IN ( 
                            SELECT {vertex_id} FROM {out_table} 
                            WHERE {dist_col}={curr_dist_val}
                        ) 
                        AND 
                        {dest} NOT IN (SELECT {vertex_id} FROM {out_table})
                    ) OR (
                        {dest} IN ( 
                            SELECT {vertex_id} FROM {out_table} 
                            WHERE {dist_col}={curr_dist_val}
                        ) 
                        AND 
                        {src} NOT IN (SELECT {vertex_id} FROM {out_table})
                    )""".format(**locals()))[0]['count']

                plpy.info("curr_dist_val = {0}".format(curr_dist_val))
                plpy.info("vct = {0}".format(vct))

    return None
